import { ALGORITHM_IDENTIFIER_V4A, AMZ_DATE_HEADER, AUTH_HEADER, SHA256_HEADER, TOKEN_HEADER, } from "@smithy/signature-v4";
import { getCanonicalHeaders } from "@smithy/signature-v4";
import { getPayloadHash } from "@smithy/signature-v4";
import { hasHeader } from "@smithy/signature-v4";
import { prepareRequest } from "@smithy/signature-v4";
import { SignatureV4Base } from "@smithy/signature-v4";
import { toHex } from "@smithy/util-hex-encoding";
import { toUint8Array } from "@smithy/util-utf8";
import { REGION_HEADER } from "./constants";
import { createSigV4aScope, getSigV4aSigningKey } from "./credentialDerivation";
import { Ec } from "./elliptic/Ec";
export class SignatureV4a extends SignatureV4Base {
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
        super({
            applyChecksum,
            credentials,
            region,
            service,
            sha256,
            uriEscapePath,
        });
    }
    async sign(toSign, options) {
        return this.signRequest(toSign, options);
    }
    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const request = prepareRequest(requestToSign);
        const { longDate, shortDate } = this.formatDate(signingDate);
        const scope = createSigV4aScope(shortDate, signingService ?? this.service);
        const pKey = await getSigV4aSigningKey(this.sha256, credentials.accessKeyId, credentials.secretAccessKey);
        request.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
            request.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        request.headers[REGION_HEADER] = region;
        const payloadHash = await getPayloadHash(request, this.sha256);
        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        const canonicalRequest = this.createCanonicalRequest(request, canonicalHeaders, payloadHash);
        const stringToSign = await this.createStringToSign(longDate, scope, canonicalRequest, ALGORITHM_IDENTIFIER_V4A);
        const signature = await this.GetSignature(pKey, stringToSign);
        request.headers[AUTH_HEADER] =
            `${ALGORITHM_IDENTIFIER_V4A} ` +
                `Credential=${credentials.accessKeyId}/${scope}, ` +
                `SignedHeaders=${this.getCanonicalHeaderList(canonicalHeaders)}, ` +
                `Signature=${signature}`;
        return request;
    }
    async GetSignature(privateKey, stringToSign) {
        const ecdsa = new Ec("p256");
        const key = ecdsa.keyFromPrivate(privateKey);
        const hash = new this.sha256();
        hash.update(toUint8Array(stringToSign));
        const hashResult = await hash.digest();
        const signature = key.sign(hashResult);
        return toHex(new Uint8Array(signature.toDER()));
    }
}
