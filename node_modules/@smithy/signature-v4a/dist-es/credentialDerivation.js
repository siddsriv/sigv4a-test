import { ALGORITHM_IDENTIFIER_V4A, KEY_TYPE_IDENTIFIER } from "@smithy/signature-v4";
import { toUint8Array } from "@smithy/util-utf8";
import { N_MINUS_TWO, ONE_AS_4_BYTES, TWOFIFTYSIX_AS_4_BYTES } from "./constants";
const signingKeyCache = {};
const cacheQueue = [];
export const createSigV4aScope = (shortDate, service) => `${shortDate}/${service}/${KEY_TYPE_IDENTIFIER}`;
export const clearCredentialCache = () => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
        delete signingKeyCache[cacheKey];
    });
};
export const getSigV4aSigningKey = async (sha256, accessKey, secretKey) => {
    let outputBufferWriter = "";
    const maxTrials = 254;
    const aws4ALength = 5;
    const inputKeyLength = aws4ALength + secretKey.length;
    const inputKeyBuf = inputKeyLength <= 64 ? new Uint8Array(64) : new Uint8Array(inputKeyLength);
    const aws4aArray = "AWS4A".split("");
    for (let index = 0; index < aws4aArray.length; index++) {
        inputKeyBuf[index] = aws4aArray[index].charCodeAt(0);
    }
    const secretKeyArray = secretKey.split("");
    for (let index = 0; index < secretKeyArray.length; index++) {
        inputKeyBuf[aws4aArray.length + index] = secretKeyArray[index].charCodeAt(0);
    }
    let trial = 1;
    while (trial < maxTrials) {
        outputBufferWriter = buildFixedInputBuffer(outputBufferWriter, accessKey, trial);
        const secretKey = inputKeyBuf.subarray(0, inputKeyLength);
        const hash = new sha256(secretKey);
        const hashVal = toUint8Array(outputBufferWriter);
        hash.update(hashVal);
        const hashedOutput = await hash.digest();
        if (isBiggerThanNMinus2(hashedOutput)) {
            trial++;
            continue;
        }
        return addOneToArray(hashedOutput);
    }
    throw new Error("Cannot derive signing key: number of maximum trials exceeded.");
};
export const buildFixedInputBuffer = (bufferInput, accessKey, counter) => {
    let outputBuffer = bufferInput;
    outputBuffer += ONE_AS_4_BYTES.map((value) => String.fromCharCode(value)).join("");
    outputBuffer += ALGORITHM_IDENTIFIER_V4A;
    outputBuffer += String.fromCharCode(0x00);
    outputBuffer += accessKey;
    outputBuffer += String.fromCharCode(counter);
    outputBuffer += TWOFIFTYSIX_AS_4_BYTES.map((value) => String.fromCharCode(value)).join("");
    return outputBuffer;
};
export const isBiggerThanNMinus2 = (value) => {
    for (let index = 0; index < value.length; index++) {
        if (value[index] > N_MINUS_TWO[index]) {
            return true;
        }
        else if (value[index] < N_MINUS_TWO[index]) {
            return false;
        }
    }
    return false;
};
export const addOneToArray = (value) => {
    const output = new Uint8Array(32);
    let carry = 1;
    for (let index = value.length - 1; index >= 0; index--) {
        const newValueAtIndex = (value[index] + carry) % 256;
        if (newValueAtIndex < value[index]) {
            carry = 1;
        }
        else {
            carry = 0;
        }
        output[index] = newValueAtIndex;
    }
    if (carry !== 0) {
        return new Uint8Array([carry, ...output]);
    }
    return output;
};
